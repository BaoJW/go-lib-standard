# 概述
fmt 包使用函数实现 I/O 格式化（类似于 C 的 printf 和 scanf 的函数）, 格式化参数源自C，但更简单。

# 打印输出

### 一般
```
%v 默认格式的值
%+v 打印struct时，会打印字段名称
%#v 是值的Go语法表示
%T 是值类型的Go语法表示
%% 一个百分号，消耗没有价值
```

### 布尔
```asciidoc
%t 打印true or false
```

### 整数
```asciidoc
%b 二进制打印
%c 由相应的Unicode代码点表示的字符
%d 10进制打印
%base 8进制打印
%q 使用Go语法安全转义的单引号字符文字。
%x 16进制，af为小写字母
%X 16进制，AF大写字母
%U Unicode格式：U + 1234; 与“U +％04X”相同
```

### 浮点和复杂的组成部分
```asciidoc
%b 十进制科学记数法，指数幂为2，以strconv.FormatFloat的方式使用'b'格式，例如-123456p-78。
%e 科学记数法，例如-1.234456e + 78
%E 科学记数法，例如-1.234456E + 78
%f 小数点但没有指数，例如123.456
%F 是%f的同义词
对于大指数，%g%e，否则为%f。精度将在下面讨论。
对于大指数，%G%E，否则为%F
```

### 字符串和字节片段
```asciidoc
%s 字符串或切片的未解释字节
%q 使用Go语法安全转义双引号字符串
%x 16进制，小写，每个字节两个字符
%X 16进制，大写，每个字节两个字符
```

### 指针
```asciidoc
%p 16进制表示法，带前导0x
```

### %v的默认格式
```asciidoc
bool:                    %t
int, int8 etc.:          %d
uint, uint8 etc.:        %d, %#x if printed with %#v
float32, complex64, etc: %g
string:                  %s
chan:                    %p
pointer:                 %p
```

### 对于复合对象，使用这些规则以递归方式打印元素
```asciidoc
struct:             {field0 field1 ...}
array, slice:       [elem0 elem1 ...]
maps:               map[key1:value1 key2:value2]
pointer to above:   &{}, &[], &map[]
```


##### 宽度由动词前面的可选十进制数字指定。如果不存在，则宽度表示值所需的任何值。在(可选)宽度之后指定精度，后面跟着一个十进制数。如果没有句点，则使用默认精度。没有以下数字的时间段指定零的精度。
```asciidoc
%f     默认宽度，默认精度
%9f    宽度为9，默认精度
%.2f   默认宽度，精度为2
%9.2f  宽度为9，精度为2
%9.f   宽度为9，精度为0
```

宽度和精度是以Unicode代码点为单位测量的，即符文。(这与C的Printf不同，后者的单位总是以字节为单位的)。其中一个或两个标志都可以用字符'*'替换，使得它们的值从下一个操作数获得，该操作数必须是int类型。

对于大多数值，width是要输出的最小符号数，如果需要，可以用空格填充格式化的表单。

然而对于字符串，字节片段和字节数组，精度会限制要格式化的输入的长度(而不是输出的大小)，如果需要则会截断。通常以符文测量，但对于使用%x或%X格式格式化的这些类型，则以字节为单位进行测量。

对于浮点数，宽度设置字段的最小宽度，精度设置小数点后的位数(如果适用)，但%g%G精度设置有效数字的总数。例如，给定12.345 格式为%6.3f 打印输出为12.345，而格式为%.3g，打印输出为12.3。%e,%f和%g的默认精度为6，对于％g，它是唯一标识值所需的最小位数。

对于复数，宽度和精度独立应用于这两个组件，并将结果括起来，因为%f应用于1.2+3.4i会产生(1.200000 + 3.400000i)。

#### 除使用%T和%p打印外，特殊的格式考虑适用于实现某些接口的操作数。按申请顺序：
1. 如果操作数是 reflect.Value，则操作数将由其保存的具体值替换，打印将继续执行下一个规则。
2. 如果一个操作数实现了Formatter接口，它将被调用。格式化程序可以很好地控制格式。
3. 如果％v verb 与＃flag（％＃v）一起使用，并且操作数实现 GoStringer 接口，则会调用该语句。如果格式（对于 Println 等隐式为 ％v）对字符串（％s％q％v％x％X）有效，则适用以下两个规则：
4. 如果操作数实现了错误接口，则将调用 Error 方法将对象转换为字符串，然后根据动词的需要对其进行格式化（如果有）。
5. 如果操作数实现方法 String() 字符串，则将调用该方法将对象转换为字符串，然后根据动词（如果有）格式化该字符串。

对于复合操作数（如切片和结构），格式以递归方式应用于每个操作数的元素，而不是作为整体应用于操作数。因此，％q将引用一个字符串片段的每个元素，％6.2f 将控制浮点数组的每个元素的格式。

但是，当使用类似字符串的动词（％s％q％x％X）打印字节切片时，它将作为单个项目与字符串相同地处理。

避免在诸如此类的情况下递归
```
type X string
func (x X) String() string { return Sprintf("<%s>", x) }
```

在重复之前转换值
```asciidoc
func (x X) String() string { return Sprintf("<%s>", string(x)) }
```

无限递归也可以由自引用数据结构触发，例如包含自身作为元素的切片，如果该类型具有String方法。然而，这种情况是罕见的，并且包装不能防止它们。

打印结构时，fmt不能，因此不会在未导出的字段上调用错误或字符串等格式化方法。

显式参数索引：

在Printf，Sprintf和Fprintf中，默认行为是每个格式化动词格式化调用中传递的连续参数。但是，紧接在动词之前的符号[n]表示要格式化第n个单索引参数。宽度或精度的'*'前面的相同符号选择保存该值的参数索引。在处理括号内的表达式[n]之后，除非另有指示，否则后续动词将使用参数n + 1，n + 2等。

例如：
```asciidoc
fmt.Sprintf("%[2]d %[1]d\n", 11, 22) 将产生“22 11”

而 fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)

相当于 fmt.Sprintf("%6.2f", 12.0) 将产生“12.00”

因为显式索引会影响后续动词，所以通过重置要重复的第一个参数的索引，可以使用此表示法多次打印相同的值
fmt.Sprintf("%d %d %#[1]x %#x", 16, 17) 将产生“16 17 0x10 0x11”
```


### 格式错误
如果为动词提供了无效参数，例如向％d提供字符串，则生成的字符串将包含问题的描述
```asciidoc
Wrong type or unknown verb: %!verb(type=value)
	Printf("%d", hi):          %!d(string=hi)
Too many arguments: %!(EXTRA type=value)
	Printf("hi", "guys"):      hi%!(EXTRA string=guys)
Too few arguments: %!verb(MISSING)
	Printf("hi%d"):            hi%!d(MISSING)
Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)
	Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
	Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
Invalid or invalid use of argument index: %!(BADINDEX)
	Printf("%*[2]d", 7):       %!d(BADINDEX)
	Printf("%.[2]d", 7):       %!d(BADINDEX)
```

所有错误都以字符串“％!”开头。有时候是一个字符（动词），最后是带括号的描述。

如果错误或字符串方法在打印例程调用时触发了混乱，则fmt软件包会从恐慌中重新格式化错误消息，并通过fmt软件包指示它。例如，如果 String 方法调用panic（“bad”），则生成的格式化消息将如下所示
```asciidoc
%!s(PANIC=bad)
```

％!s只显示故障发生时使用的打印动词。但是，如果由nil接收器引起的错误或字符串方法引起的混乱，则输出是未修饰的字符串"< nil >"。


# 扫描
一组类似的函数扫描格式化文本以产生值。Scan，Scanf 和 Scanln从os.Stdin读取；Fscan，Fscanf 和 Fscanln 从指定的io.Reader读取; Sscan，Sscanf 和 Sscanln 从参数字符串中读取。

Scan，Fscan，Sscan 将输入中的换行符视为空格。

Scanln，Fscanln 和 Sscanln 在换行符处停止扫描并要求项目后跟换行符或 EOF。

Scanf，Fscanf 和 Sscanf 根据格式字符串解析参数，类似于 Printf 的格式字符串。在下面的文本中，'space' 表示除换行符之外的任何 Unicode 空白字符。

在格式字符串中，％字符引入的动词消耗并解析输入；这些动词在下面更详细地描述。格式中除％，空格或换行符之外的字符恰好消耗必须存在的输入字符。在格式字符串中具有零个或多个空格的换行符在输入中使用零个或多个空格，后跟单个换行符或输入的结尾。格式字符串中换行符后面的空格在输入中占用零个或多个空格。否则，格式字符串中的一个或多个空格的任何运行在输入中消耗尽可能多的空格。除非格式字符串中的空格运行与换行符相邻，否则运行必须至少占用输入的一个空格或找到输入的结尾。

空格和换行符的处理与C的 scanf 系列的处理不同：在C中，换行符被视为任何其他空格，当格式字符串中的空格行没有在输入中消耗空间时，它永远不会出错。

动词的行为类似于 Printf。例如，％x 将整数扫描为十六进制数，％v 将扫描该值的默认表示格式。Printf 动词 ％p和 ％T 以及标志＃和+未实现，动词 ％e％E％f％F％g和％G 都是等效的，并扫描任何浮点或复数值。

由动词处理的输入是隐式空格分隔的：除了 ％c 之外的每个动词的实现都是从剩余输入中丢弃前导空格开始的，而 ％s 动词（和 ％v 读入字符串）在第一个空格处停止消耗输入或换行符。

当扫描没有格式的整数或使用％v动词时，接受熟悉的基本设置前缀0（八进制）和0x（十六进制）。

宽度在输入文本中解释，但没有精确扫描的语法（没有 ％5.2f，只有 ％5f）。如果提供了宽度，则在修剪前导空格后应用宽度，并指定要读取的最大符文数以满足动词。例如，
```asciidoc
Sscanf(" 1234567 ", "%5s%d", &s, &i)
```

将s设置为“12345”，将i设置为67
```asciidoc
Sscanf(" 12 34 567 ", "%5s%d", &s, &i)
```
将s设置为“12”，将i设置为 34。

在所有扫描功能中，紧接着换行后的回车被视为普通换行符（\r\n 表示与\n 相同）。

在所有扫描功能中，如果操作数实现方法 Scan（即，它实现了 Scanner 接口），则该方法将用于扫描该操作数的文本。此外，如果扫描的参数数量小于提供的参数数量，则返回错误。

要扫描的所有参数必须是指向基本类型的指针或 Scanner 接口的实现。

与 Scanf 和 Fscanf 一样，Sscanf 无需消耗其全部输入。无法恢复使用的输入字符串 Sscanf 的数量。

注意：Fscan 等可以读取它们返回的输入之后的一个字符（符文），这意味着调用扫描例程的循环可能会跳过某些输入。仅当输入值之间没有空格时，这通常是一个问题。如果提供给 Fscan 的阅读器实现了 ReadRune，那么该方法将用于读取字符。如果读者也实现了 UnreadRune，那么该方法将用于保存字符，连续调用不会丢失数据。要将 ReadRune 和 UnreadRune 方法附加到没有该功能的阅读器，请使用 bufio.NewReader。




































